# RFC-XXXX: "CoreJam"

|                 |                                                                                             |
| --------------- | ------------------------------------------------------------------------------------------- |
| **Start Date**  | 11 September 2023                                                                                |
| **Description** | Parallelised, decentralised, permissionless state-machine based on a multistage Collect-Refine-Join-Accumulate model. |
| **Authors**     | Gavin Wood                                                                    |


## Summary

This is a proposal to fundamentally alter the workload done on the Polkadot Relay-chain, both in terms of that which is done "on-chain", i.e. by all Relay Chain Validators (*Validators*) as well as that which is done "in-core", i.e. distributed among subsets of the Validators (*Validator Groups*). The target is to create a model which closely matches the underlying technical architecture and is both generic and permissionlessly extensible.

In the proposed model, code is stored on-chain with two entry-points. Workloads are collated and processed in-core (and thus parallelized) using one entry-point, whereas the refined outputs of this processing are gathered together and an on-chain state-machine progressed according to the other.

While somewhat reminiscent of the Map-Reduce paradigm, a comprehensive analogy cannot be taken: the in-core processing code does not transform a set of inputs, but is rather used to refine entirely arbitrary input data collected by some third-party. Instead, and in accordance, we term it *Collect-Refine-Join-Accumulate*.

## Motivation

Polkadot was originally designed as a means of validating state transitions of Webassembly-defined state machines known as *Parachain Validation Functions*. These state machines were envisioned to be long-lived (of the order of years) and transitioning continuously, at the "full capacity" of modern single-threaded hardware held in consensus over the internet, and in isolation to any other such state machines.

Having actually built Polkadot, it became clear that the flexibility of the machinery implementing it allowed for a more diverse set of usage patterns and models. Parathreads, which came to be known as *On-Demand Parachains* (ODP) is one such model. This was underlined by other proposals to allow for a more decentralised administration of how the underlying Polkadot Core resource is procured, in particular *Agile Coretime*.

More recently, the idea of having small to medium size programs executing without its own surrounding blockchain using only Relay-chain resources has been discussed in detail primarily around the *Coreplay* proposal. It therefore seems short-sighted to assume other models could not exist for utilizing the Relay-chain's "Core" resource. Therefore in much the same way that Agile Coretime originally strived to provide the most general model of *procuring* Relay-chain's Core resource, it seems sensible to strive to find a similarly general model for *utilizing* this resource, one minimizing the difference between the valuable function of the Validators and the service offered by Polkadot.

Beyond delivering additional value through the increased potential for use-cases that this flexibility allows, our motivation extends to gaining stability: a future-proof platform allowing teams to build on it without fear of high maintenance burden, continuous bitrot or a technological rug-pull at some later date. Secondly, we are motivated by reducing barriers for new teams, allowing the Polkadot platform to harness the power of the crowd which permissionless systems uniquely enable.

Being extensible, the Relay-chain becomes far more open to experimentation within this paradigm than the classical Parachain Proof-of-Validity and Validation Function as is the case at present. Being permissionless opens Polkadot experimentation to individuals and teams beyond those core developers.

## Requirements

In order of importance:

1. The proposal must be compatible, in principle, with the preexisting parachain model.
2. The proposal must facilitate the implementation of Coreplay.
3. The proposal must be compatible with Agile Coretime, as detailed in RFC#0001.
4. Implementation of the proposal should need minimal changes to all production logic.
5. Utilization of Coretime must be accessible.
6. Utilization of Coretime must be permissionless.
7. The nature of Coretime should closely match the nature of resources generated by Polkadot.
8. Minimal opinionation should be introduced over the format, nature and usage of Coretime.

## Stakeholders

1. Anyone with exposure to the DOT token economy.
2. Anyone wanting to create decentralised/unstoppable/resilient applications.
3. Teams already building on Polkadot.

## Explanation

The idea of *Proof-of-Validity* and *Parachain Validation Function* as first-class concepts in the Polkadot protocol is removed. These are now specializations of more general concepts.

We introduce a number of new interrelated concepts: *Work Package*, *Work Class*, *Work Item*, *Work Output*, *Work Class Trie*.


```rust
mod v0 {
    const PROGRESS_WEIGHT_PER_PACKAGE: Weight = MAX_BLOCK_WEIGHT * 3 / 4;
    type WorkClass = u32;
    type WorkPayload = Vec<u8>;
    struct WorkItem {
        class: WorkClass,
        payload: WorkPayload,
    }
    type MaxWorkItemsInPackage = ConstU32<16>;
    struct WorkPackage {
        authorization: Vec<u8>,
        progressions: BoundedVec<(WorkClass, Weight), MaxWorkItemsInPackage>,
        items: BoundedVec<WorkItem, MaxWorkItemsInPackage>,
    }
}
type MaxWorkPackageSize = ConstU32<5 * 1024 * 1024>;
struct EncodedWorkPackage {
    version: u32,
    encoded: BoundedVec<u8, MaxWorkPackageSize>,
}
impl TryFrom<EncodedWorkPackage> for v0::WorkPackage {
    type Error = ();
    fn try_from(e: EncodedWorkPackage) -> Result<Self, ()> {
        match e.version {
            0 => Self::decode(&mut &e.encoded[..]).map_err(|_| ()),
            _ => Err(()),
        }
    }
}
```

A *Work Package* is an *Authorization* together with a series of *Work Items*, limited in plurality, versioned and with a maximum encoded size. There is a third field `progressions` to provide weight-limit information for the final *Accumulate* stage. It must fulfill a constraint that the sum over all `Weight` items (i.e. the second item in the `Vec`'s tuple) must be no greater than `PROGRESS_WEIGHT_PER_PACKAGE`.

Work Items are a pair of class and payload, where the `class` identifies the Class of Work to be done in this item (*Work Class*).

### Authorization and Authorizers

An *Authorizer* is parameterized procedure:

```rust
type CodeHash = [u8; 32];
type AuthParamSize = ConstU32<1024>;
type AuthParam = BoundedVec<u8, AuthParamSize>;
struct Authorizer {
    code_hash: CodeHash,
    param: AuthParam,
}
```

The `code_hash` of the Authorizer is assumed to be the hash of some code accessible in the Relay-chain's Storage pallet. The procedure itself is called the *Authorization Procedure* (`AuthProcedure`) and is expressed in this code (which must be capable of in-core VM execution). Its entry-point prototype is:

```rust
fn is_authorized(param: &AuthParam, package: &WorkPackage) -> bool;
```

If the `is_authorized` function overruns the system-wide limit or panicks on some input, it is considered equivalent to returning `false`.

A single `Authorizer` value is associated with the index of the Core at a particular Relay-chain block and limits in some way what Work Packages may be legally processed by that Core.

Since encoded `Authorizer` values may be fairly large (up to 1,038 bytes here), they may not be a drop-in replacement for the `ParaId`/`TaskId` used at present in the Agile Coretime interface. Because of this, we provide a lookup mechanism allowing a much shorter `AuthId` to be used within the Coretime scheduling messaging. Conveniently, this is precisely the same datatype size (32-bit) as a `ParaId`/`TaskId`.

There is an Authorizations Pallet which stores the association. Adding a new piece of code is permissionless but requires a deposit commensurate with its size.

```rust
type AuthId = u32;
type Authorizers = StorageMap<AuthId, Authorizer>;
```

An *Authorization* is simply a blob which helps the Authorizer recognize a properly authorized Work Package. No constraints are placed on Authorizers over how they may interpret this blob. Expected authorization content includes signatures, Merkle-proofs and more exotic succinct zero-knowledge proofs.

_(Note: depending on future Relay-chain Coretime scheduling implementation concerns, a window of Relay-chain blocks)._

The need of validators to be rewarded for doing work they might reasonably expect to be useful competes with that of the Coretime procurers to be certain to get work done which is useful to them. In Polkadot 1.0, validators only get rewarded for PoVs ("work packages") which do not panic or overrun. This ensures that validators are well-incentivized to ensure that their computation is useful for the assigned parachain. This incentive model works adequately where all PVF code is of high quality and collators are few and static.

However with this proposal (and even the advent of on-demand parachains), validators have little ability to identify a high-quality Work Package builder and the permissionless design means a greater expectation of flawed code executing in-core. Because of this, we make a slightly modified approach: Work Packages must have a valid Authorization, i.e. the Coretime-assigned `is_authorized` returns `true` when provided with the Work Package. However, Validators get rewarded for *any* such authorized Work Package, even one which ultimately panics or overruns on its evaluation.

This ensures that Validators do a strictly limited amount of work before knowing whether they will be rewarded and are able to discontinue and attempt other candidates earlier than would otherwise be the case. There is the possibility of wasting Coretime by processing Work Packages which result in error, but well-written authorization procedures can mitigate this risk by making a prior validation of the Work Items.

### Collect-Refine

The `refine` function is implemented as an entry-point inside a code blob which is stored on-chain and whose hash is associated with the Work Class.

```rust
type ClassCodeHash = StorageMap<ClassId, CodeHash>;
```

```rust
type WorkOutputLen = ConstU32<1024>;
type WorkOutput = BoundedVec<u8, WorkOutputLen>;
fn refine(payload: WorkPayload) -> WorkOutput;
```

Both `refine` and `is_authorized` are only ever executed on-core. Within this environment, we need to ensure that we can interrupt computation not long after some well-specified limit and deterministically determine when an invocation of the VM exhausts this limit. Since the exact point at which interruption of computation need not be deterministic, it is expected to be executed by a streaming JIT transpiler with a means of approximate and overshooting interruption coupled with deterministic metering.

Several host functions, largely in line with the *PVF* host functions, are supplied. Two additional ones include:

```rust
/// Determine the preimage of `hash` utilizing the Relay-chain Storage pallet.
fn lookup(hash: [u8; 32]) -> Vec<u8>;
/// Determine the state root of the block at given `height`.
fn state_root(height: u32) -> Option<[u8; 32]>;
```

Other host functions will allow for the possibility of executing a WebAssembly payload (for example, a Parachain Validation Function) or instantiating and entering a subordinate RISCV VM (for example for Actor Progressions).

When applying `refine` from the client code, we must allow for the possibility that the VM exits unexpectedly or does not end. If this happens, then the Work Item is invalidated. Thus we define a type `WorkResult`:

```rust
enum WorkError {
    Timeout,
    Panic,
}
type WorkResult = Result<WorkOutput, WorkError>;
fn apply_refine(item: WorkItem) -> WorkResult;
```

Each Relay-chain block, every Validator Group representing a Core which is assigned work provides up to one Work Result coherent with the assignment of that Core. Validators are rewarded when they take part in their Group and process a Work Package. This culminates in providing a *Work Result* to the Relay-chain block author. If no Work Result is provided (or if the Relay-chain block author refuses to include it), then that Validator Group is not rewarded for that block.

### Join-Accumulate

Join-Accumulate is a second stage of computation and is independent from Collect-Refine. Unlike with the computation in Collect-Refine which happens contemporaneously within one of many isolated cores, the computation of Join-Accumulate is both entirely synchronous with all other computation of its stage and operates within (and has access to) the same shared state-machine.

The Join-Progess stage may be seen as a synchronized counterpart to the parallelised Collect-Refine stage. It may be used to integrate the work done from the context of an isolated VM into a self-consistent world model. In concrete terms this means ensuring that the independent work components, which cannot have been aware of each other during the Collect-Refine stage, do not conflict in some way. Less dramatically, this stage may be used to enforce ordering or provide a synchronisation point (e.g. for combining entropy in a sharded RNG). Finally, this stage may be a sensible place to manage asynchronous interactions and oversee message queue transitions.

The user-supplied `accumulate` function defines the elective portion of the Join-Accumulate stage. This is executed in a *metered* format, meaning it must be able to be executed in a sandboxed and non-deterministic fashion but also with a means of providing an upper limit on the amount of weight it may consume and a guarantee that this limit will never be breached.

Practically speaking, we may allow a similar VM execution metering system similar to that for the `refine` execution, whereby we do not require a strictly deterministic means of interrupting, but do require deterministic metering and only approximate interruption. This would mean that full-nodes and Relay-chain validators could be made to execute some additional margin worth of computation without payment, though any attack could easily be mitigated by attaching a fixed cost (either economically or in weight terms) to an VM invocation.

The function signature to the `accumulate` entry-point in the Work Class's code blob is:

```rust
fn accumulate(results: Vec<(Authorization, Vec<(ItemHash, WorkResult)>)>);
type ItemHash = [u8; 32];
```

As stated, there is an amount of weight which it is allowed to use before being forcibly terminated and any non-committed state changes lost. This is the sum of all `progressions` fields whose first item is the particular Work Class across all scheduled Work Packages.

Work Items are identified by their hash (`ItemHash`). We provide both the authorization of the package and the item identifers and their results in order to allow the `refine` logic to take appropriate action in the case that an invalid Work Item was issued.

_(Note for later: We may wish to provide a more light-client friendly Work Item identifier than a simple hash; perhaps a Merkle root of equal-size segments.)_

Read-access to the entire Relay-chain state is allowed, but no direct write access may be provided since `refine` is untrusted code. `set_storage` may fail if an insufficient deposit is held under the Work Class's account.

```rust
fn checkpoint() -> Weight;
fn weight_remaining() -> Weight;
fn get_work_storage(key: &[u8]) -> Result<Vec<u8>>;
fn get_work_storage_len(key: &[u8]);
fn set_work_storage(key: &[u8], value: &[u8]) -> Result<(), ()>;
fn remove_work_storage(key: &[u8]);
```

Full access to a child trie specific to the Work Class is provided through the `work_storage` host functions. Since `refine` is permissionless and untrusted code, we must ensure that its child trie does not grow to degrade the Relay-chain's overall performance or place untenable requirements on the storage of full-nodes. To this goal, we require an account sovereign to the Work Class to be holding an amount of funds proportional to the overall storage footprint of its Child Trie. `set_work_storage` may return an error should the balance requirement not be met.

Host functions are provided allowing any state changes to be committed at fail-safe checkpoints to provide resilience in case of weight overrun (or even buggy code which panics). The amount of weight remaining may also be queried without setting a checkpoint. `Weight` is expressed in a regular fashion for a solo-chain (i.e. one-dimensional).

Other host functions, including some to access Relay-chain hosted services such as the Balances and Storage Pallet may also be provided commensurate with this executing on-chain.

_(Note for discussion: Should we be considering light-client proof size at all here?)_

We can already imagine two kinds of Work Class: *Parachain Validation* (as per Polkadot 1.0) and *Actor Progression* (as per Coreplay). Given how abstract the model is, one might reasonably expect many more.

### Relay-chain Storage Pallet

There is a general need to be able to reference large, immutable and long-term data payloads both on-chain and in-core. This is both the case for fixed-function logic such as fetching the VM code for `refine` and `accumulate` as well as from within Work Packages themselves.

Owing to the potential for forks and disputes to happen beyond the scope of initial validation, there are certain quite subtle requirements over what data held on-chain may be utilized in-core. Because of this, it makes sense to have a general solution which is known to be safe to use in all circumstances. We call this solution the *Storage Pallet*.

The Storage Pallet provides a simple API, accessible to untrusted code through host functions & extrinsics and to trusted Relay-chain code via a trait interface.

```rust
trait Storage {
    /// Immutable function to attempt to determine the preimage for the given `hash`.
    fn lookup(hash: &[u8; 32]) -> Option<Vec<u8>>;

    /// Allow a particular preimage to be `provide`d.
    /// Once provided, this will be available through `lookup` until
    /// `unrequest` is called.
    fn request(hash: &[u8; 32], len: usize) -> bool;
    /// Remove request that some data be made available. If the data was never
    /// available or the data will remain available due to another request,
    /// then `false` is returned and `expunge` may be called immediately.
    /// Otherwise, `true` is returned and `expunge` may be called in
    /// 24 hours.
    fn unrequest(hash: &[u8; 32]) -> bool;

    // Functions used by implementations of untrusted functions; such as
    // extrinsics or host functions.

    /// Place a deposit in order to allow a particular preimage to be `provide`d.
    /// Once provided, this will be available through `lookup` until
    /// `unrequest_untrusted` is called.
    fn request_untrusted(depositor: &AccountId, hash: &[u8; 32], len: usize);
    /// Remove request that some data be made available. If the data was never
    /// available or the data will remain available due to another request,
    /// then `false` is returned and `expunge_untrusted` may be called immediately.
    /// Otherwise, `true` is returned and `expunge_untrusted` may be called in
    /// 24 hours.
    fn unrequest_untrusted(depositor: &AccountId, hash: &[u8; 32]) -> bool;

    // Permissionless items utilizable directly by an extrinsic or task.

    /// Provide the preimage of some requested hash. Returns `Some` if its hash
    /// was requested; `None` otherwise.
    ///
    /// Usually utilized by an extrinsic and is free if `Some` is returned.
    fn provide(preimage: &[u8]) -> Option<[u8; 32]>;
    /// Potentially remove the preimage of `hash` from the chain when it was
    /// unrequested using `unrequest`. `Ok` is returned iff the operation is
    /// valid.
    ///
    /// Usually utilized by a task and is free if it returns `Ok`.
    fn expunge(hash: &[u8; 32]) -> Result<(), ()>;
    /// Return the deposit associated with the removal of the request by
    /// `depositor` using `unrequest_untrusted`. Potentially
    /// remove the preimage of `hash` from the chain also.  `Ok` is returned
    /// iff the operation is valid.
    ///
    /// Usually utilized by a task and is free if it returns `Ok`.
    fn expunge_untrusted(depositor: &AccountId, hash: &[u8; 32]) -> Result<(), ()>;

    /// Equivalent to `request` followed immediately by `provide`.
    fn store(data: &[u8]) -> [u8; 32];
}
```

Internally, data is stored with a reference count so that two separate usages of `store` need not be concerned about the other.

Every piece of data stored for an untrusted caller requires a sizeable deposit. When used by untrusted code via a host function, the `depositor` would be set to an account controlled by the executing code (e.g. the Work Class's sovereign account).

Removing data happens in a two-phase procedure; first the data is unrequested, signalling that calling `lookup` on its hash may no longer work (it may still work if there are other
requests active). 24 hours following this, the data is expunged with a second call which, actually removes the data from the chain assuming no other requests for it are active.

Only once expunge is called successfuly is the deposit returned. If the data was never provided, or is additional requests are still active, then expunge may be called immediately after a successful unrequest.

### Notes on Agile Coretime

Crucially, a *Task* is no longer a first-class concept. Thus the Agile Coretime model, which in large part allows Coretime to be assigned to a Task Identifier from the Coretime chain, would need to be modified to avoid a hard dependency on this.

In this proposal, we replace the concept of a Task with a more general ticketing system; Coretime is assigned to an *Authorizer* instead, a parameterized function. This would allow a succinct *Authorization* (i.e. a small blob of data) to be included in the Work Package which, when fed into the relevant Authorizer function could verify that some Work Package is indeed allowed to utilize that Core at (roughly) that time. A simple proof system would be a regular PKI signature. More complex proof systems could include more exotic cryptography (e.g. multisignatures or zk-SNARKs).

In this model, we would expect any authorized Work Packages which panic or overrun to result in a punishment to the specific author by the logic of the Work Class.

### Notes for migrating from a Parachain-centric model

All Parachain-specific data held on the Relay-chain including the means of tracking the Head Data and Code would be held in the Parachains Work Class (Child) Trie. The Work Package would be essentially equivalent to the current PoV blob, though prefixed by the Work Class. `refine` would prove the validity of the parachain transition described in the PoV which is the Work Package. The Parachains Work Output would provide the basis for the input of what is currently termed the Paras Inherent. `accumulate` would identify and resolve any colliding transitions and manage message queue heads, much the same as the current hard-coded logic of the Relay-chain.

We should consider utilizing the Storage Pallet for Parachain Code and store only a hash in the Parachains Work Class Trie.

### Notes for implementing the Actor Progression model

Actor code is stored in the Storage Pallet. Actor-specific data including code hash, VM memory hash and sequence number is stored in the Actor Work Class Trie under that Actor's identifier. The Work Package would include pre-transition VM memories of actors to be progressed whose hash matches the VM memory hash stored on-chain and any additional data required for execution by the actors (including, perhaps, swappable memory pages). The `refine` function would initiate the relevant VMs and make entries into those VMs in line with the Work Package's manifest. The Work Output would provide a vector of actor progressions made including their identifer, pre- and post-VM memory hashes and sequence numbers. The `accumulate` function would identify and resolve any conflicting progressions and update the Actor Work Class Trie with the progressed actors' new states. More detailed information is given in the Coreplay RFC.

## Performance, Ergonomics and Compatibility

This system must be broadly compatible with our existing Parachain Validation Function/Proof-of-Validity model, however a specific feasibility study into transitioning/migration has yet to be completed.

To aid swift deployment, the Relay-chain may retain its existing parachain-specific logic "hardcoded", and the Coregap logic added separately, with Work Class "zero" being special-cased to mean "the hard-coded Parachain logic".

## Testing, Security and Privacy

Standard Polkadot testing and security auditing applies.

The proposal introduces no new privacy concerns.

## Future Directions and Related Material

Important considerations include:

1. In the case of composite Work Packages, allowing synchronous (and therefore causal) interactions between the subpackages. If this were to be the case, then some sort of synchronisation sentinel would be needed to ensure that should one subpackage result without the expected effects on its Work Class State (by virtue of the `accumulate` outcome for that subpackage), that the `accumulate` of any causally entangled subpackages takes appropriate account for this (i.e. by dropping it and not effecting any changes from it).

## Drawbacks, Alternatives and Unknowns

None at present.

## Prior Art and References

None.



# Chat
for this we need a pallet on the RC to allow arbitrary data to be stored for a deposit, with a safeguard that it would remain in RC state for at least 24 hours (in case of dispute); and a host function to allow the PoV to reference it.
this issue is that for fast-changing data, you'd need to store all of the different images for 24 hours each.
this would quickly get prohibitive.
Yeah, but then we can not give these tasks that much memory. Maybe around 0.5 MiB to 1 MiB (depending on how well they compress) 
yeah
tasks which expect to execute alone could get ~2MB.
Gav
an alternative would be to require the author-network to compute the precise output itself and send it to the storage chain separately.
and if we do this, then up to around 4.5MB.
it's not much by today's desktop standards, but it still beats the shit out of smart contracts.
In reply to 
Gav
Gav
and if we do this, then up to around 4.5MB.
Why can we then double it? What do I miss?
5MB PoV limit.
best case you need to provide the full pre-state (with which to initialize the VM) and a hash of the post-state (to verify computation)
however, it's not clear where you get the next block's pre-state from.
one solution is to provide both pre- and post-state into the PoV and piggy-back on Polkadot's 24-hour availability system
(as long as you build the next block at most 24 hours from the last)
You can get the next state by re executing? 
Or keep it in your local cache or whatever 
but you don't necessarily have other tasks at that time.
or the RC state.
Ahh I see
or, indeed, the pre-state.
PoV disappears after 24 hours.
We can not recalculate all the state 
no
this means an average of 5MB / 2 memory bandwidth per block.
minus a bit for smaller tasks to coordinate with gives 2 - 2.5MB.
But if we put the post state into availability system it should work as well? 
but we assume the PoV accounts for All of the RCV's resources.
if it doesn't then we should just increase the PoV size.
Yeah fine 
i.e. if the RCV can handle 5MB PoV (availability) plus 5MB additional availability, then isn't it just easier to say 10MB PoV?
I think the limit currently is just from the networking side
Aka we could not even really handle these big PoVs 
But with async backing it should now be possible 
maybe i'm wrong here - if the limit of 5MB PoV is less about availability and more about transport from the collator, then sure, we can split it into a PoV limit and an availability limit
and have 5MB PoV and 10MB availability.
but i assumed that the bottleneck was just availability.
definitely an assumption to test
Yeah we should find out. Maybe I probably neglecting the erasure coding 
since there is a difference between data from some other guy (pre-state) and data which you generate yourself (post-state)
assuming i'm right about the bottleneck, then the best we could do without some form of paging (which should be easy enough to implement with jan's help) is having the post-state be computed on the author-network and placed in the storage chain.
jan says that paging is pretty trivial to customise on his RISCV VM.
just a segfault everytime a new page is required and we can either suspend + snapshot; or fetch + assign the page and continue.
Gav
just a segfault everytime a new page is required and we can either suspend + snapshot; or fetch + assign the page and continue.
Yeah, that was also my idea.
But yeah, for the beginning we can probably start with 0.5MiB of memory 
we have 16KB pages currently, and we'll already likely be doing something similar for running multiple stacks
Basti.await
But yeah, for the beginning we can probably start with 0.5MiB of memory 
yup
definitely enough for a PoC.
but we will still need a new PoV format.
i.e. where we can:
a) request arbitrary data from the RCTaskStorage pallet (which guarantees data placed on it cannot be removed for 24 hours after last read).
b) progress a particular task (in whatever order) with weight spec
c) provide data into a particular task (in whatever order) with weight spec
we might also have a more abstract PoV protocol which allows for different classes of task.
and specifies in Wasm or whatever exactly how to interpret a PoV
then we reformulate the Parachain PoV into this "smart contract".
and we would create a new Task PoV format as just another instance within this overarching protocol.
e.g. this protocol could define UMP, DMP, XCMP and the initial version of the Actors-PoV format might reasonably not include this logic.
but an upgrade later could allow actors to use this stuff.
the main difference with just "hardcoding" it into the RC logic directly is that it could be permissionless - other teams could come up with their own PoV formats and protocols to determine validity.
ok so i've thought about it a bit.
i think there's a route forward for what i referenced up there as "generic PoVs".
in fact they cease to be "PoVs" at this point.
they're just "Work Packages" since you're not proving anything, you're just using the RCVs for compute.
we would define the concept of a Work Class.
all WPs must have a WT. the WT defines what it means to interpret/execute the WP.
we'd initially have two WTs: Parachains and Tasks.
WTs would be permissionless and would come with two main blobs; one (which I'll call map) which can still be in Wasm (since it runs off-chain at a level higher than the PVF) and one (called reduce) which must be strictly metered (so RISCV or very slow Wasm).
as the name suggests, the first represents map and the second represents reduce of a map-reduce pattern.
the first takes the WP as an argument and can inspect any data held in the RCTaskStore.
it then either panics (invalid) or returns a fixed-size (or rather known-maximum-length) blob.
all such blobs and panics are batched up into a Vec and fed into a WT-defined reduce function, with its max_weight = to the block_weight multiplied by the ratio of cores used for this WT compared to all cores.
all WTs have their own child trie.
only this reduce function may alter data in that trie.
for the Parachain WT, this child trie would include all the parachain-specific data (code and state); the ParachainWP output type would basically be the per-chain paras-inherent arguments, and so the PWT reduce function would basically be the paras-inherent logic.
for the Actors WT, this child trie would include Actor specific stuff like codehash (the actual code would be stored in the RCTaskStore) and RISCVVM memory hash, as well as sequence number.
The Actor output would include enough information on which actor-combinations got (maybe) progressed to allow the proper progressions to be recorded in the Actor Child Trie by the reduce function. essentially just the logic i already define in the RFC.
So the Actor map function would interpret the WorkPackage as a manifest and fetch all actor code, initialise each Actor's VM and start them with the entry points according to the manifest.
with this model, anyone could add their own Work Classs.
So if RobK/Arkadiy/Dave can implement the spec, we can focus on writing up the Actor-based map and reduce function. They need not be concerned with Actors at all.
sound sensible?
Good question :P 
So the map would have access to fetch the code from the relay chain?
And the map would be trusted code?
That is the same for every WT? 
neither map nor reduce are trusted
Gav
neither map nor reduce are trusted
Ahh yeah, you said it
map would only be able to read the part of RC state which is guaranteed to be available for 24 hours; this basically just means the RCTaskStorage.
But the code executed in reduce is defined by the output of map?
yes
Gav
map would only be able to read the part of RC state which is guaranteed to be available for 24 hours; this basically just means the RCTaskStorage.
The code to execute will be referenced by the code hash and this code hash needs to be "somewhere". Currently we store in the relay chain state
yeah, the code would need to be in the "RCTaskStore" (should be the RCWorkStore, i guess)
there is the question about the WorkType Child Trie
This is the child trie you mentioned? 
(The RCTaskStore) 
RCWorkStore is the on-chain paid data repository which guarantees data remains available for 24 hours after removal
there is also the WorkTypeChildTrie.
i guess this would need to guarantee some sort of dispute-availability also.
Gav
there is also the WorkTypeChildTrie.
This is stored in the RC state?
yes
it's a child trie.
yeah, just wanted to be sure :P 
Gav
i guess this would need to guarantee some sort of dispute-availability also.
Yeah for sure. If we need the data as input of the validation
we might need to limit this.
yeah, i think we don't need any of this data.
And map to reduce would be something like Vec<Work { code_hash, function, params, max_weight: Option<Weight> }>?
map output would basically be Vec<ProvisionalProgression>
where struct ProvisionalProgression { actor: ActorId, code: [u8;32], prestate: [u8;32], poststate: [u8;32] }
then reduce would take a Vec<Vec<ProvisionalProgression>>
reduce would check there are no collisions (same actor progressing from same poststate), that the code executed is the expected code hash of the actor and that the prestate fits into a coherent progression of the actor (which might not be the old poststate since the actor could be doing multiple progressions in a single RC block).
So you want to execute the actor code from within reduce?
no
actor code gets executed off-chain in map.
output of map informs reduce what it has done.
it's up to reduce to figure out how to combine all of this into a coherent RC state update.
But when is reduce executed? As part of the RC block execution/building?
yeah
reduce is on-chain,
it accepts a Vec<WorkTypeOutput>
WorkTypeOutput is an output specific to WorkType, i.e. WorkTypeOutput in fn map(WorkPackage) -> Result<WorkTypeOutput, WorkPackageError>
Okay, I see where you want to go. 
Gav
then reduce would take a Vec<Vec<ProvisionalProgression>>
Why this, because there can be multiple WorkPackages being progressed in one RC?
yes, one for every core.
those ProvisionalProgressions appearing together in an inner Vec have been co-scheduled.
it might possibly make a difference inside of reduce to know what progressions have happened together on the same core.
Okay. So reduce is getting all the WorkOutputs of all cores for one WT?
precisely.
one WT would be the whole of parachains, UMP, DMP, XCMP.
Yeah
another WT would be the whole actor environment.
Actors and parachains will never be able to talk to each other? 
yeah, we can imagine actor-v2 WT which includes the possibility of XCMP/DMP/UMP.
but i would get a basic version of actors done first.
Basti.await
Actors and parachains will never be able to talk to each other? 
I more meant "co-scheduled"
just to show it's possible.
In reply to 
Basti.await
Basti.await
I more meant "co-scheduled"
perhaps for actors-v3 which would allow WPs to include both parachain and actor progressions
but we should be able to get most of the benefits leaving it as XCMP
if actors work as well as we expect, then the need for chains will dramatically reduce
In reply to 
Basti.await
Gav
perhaps for actors-v3 which would allow WPs to include both parachain and actor progressions
Okay, my only comment on this would be that we then need to ensure that parachains and actors are not scheduled in different groups of "WTs"
But maybe some simple "was updated in RC block X" should be enough 
But yeah, what you propose sounds reasonable 
In reply to 
Gav
Basti.await
Okay, my only comment on this would be that we then need to ensure that parachains and actors are not scheduled in different groups of "WTs"
yeah, i think we would need to provide some sort of hard-coded-function on the RC to migrate between WTs in this case.
parachains couldn't be part of two WTs at once
Okay 
but again, i don't see too much benefit in synchronous composability between actors and chains
Yeah
Just wanted to ask
and it complicates things massively
And I think chains are an old concept anyway with coreplay :P 
quite.
the level of experimentation this would provide is pretty immense
Yes 
This would also quite help for stuff like "elastic scaling" etc. 
basically, just turn polkadot into a global, secure map-reduce computer. 
We could just experiment 
As a new WT
yup